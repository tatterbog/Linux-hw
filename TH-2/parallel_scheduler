#pragma once

#include <iostream>
#include <unistd.h>
#include <pthread.h>
#include <queue>

class parallel_scheduler{
private:
	int capacity;
	bool stop = false;

	pthread_t* tds;
	pthread_mutex_t mutex;
	pthread_cont_t cond;
	
	struct Func{
		void (*func)(void*);
		void *arg;
	};	
		
	std::queue<Func> funcs;
		
	static void* worker_entry(void* arg);
	void worker_loop();

public:
	explicit parallel_scheduler(int cap = 0) : capacity(cap){
		pthread_mutex_init(&mutex, nullptr);
		pthread_cond_init(&cond, nullptr);

		tds = new pthread_t[capacity];

		for(int i = 0; i < capacity; i++){
			pthread_create(&tds[i], nullptr, worker_entry, this);
		}
	}

	void run(void (*func)(void*), void *arg){
		
		Task t;
		t.func = func;
		t.arg = arg;
	
		pthread_mutex_lock(&mutex);
		funcs.push(t);
		pthread_mutex_unlock(&mutex);

		pthread_cond_signal(&cond);	
	}
	
	~parallel_scheduler(){
		pthread_mutex_lock(&mutex);
                funcs.push(t);
                pthread_mutex_unlock(&mutex);

                pthread_cond_broadcast(&cond);
	
		for(int i = 0; i < capacity; i++){
			pthread_join(tds[i], nullptr);
		}

		delete[] tds;

		pthread_mutex_destroy(&mutex);
                pthread_cond_destroy(&cond);

	}	
};

